<font size =6>**计算机图形学 大作业 小组报告**</font>



## 成员信息

【学号】   22362078

【姓名】   王泽地



【学号】  22307014

【姓名】   黄宏亮



【学号】  22336296

【姓名】   张鸿锴



## 1. 引言

1.1 **背景与意义**

计算机图形学是一个跨学科的领域，涉及计算机科学、数学、物理学以及艺术等多个学科，其应用领域广泛且重要。首先，在娱乐行业，计算机图形学被广泛应用于视频游戏、动画电影和虚拟现实（VR）等领域，通过生成高质量的视觉效果和沉浸式体验，极大地丰富了用户的娱乐体验。其次，在建筑设计和室内装潢领域，计算机图形学使得设计师能够创建逼真的三维模型，帮助客户在实际施工前可视化设计效果，从而提高设计的准确性和客户的满意度。此外，计算机图形学在医学成像、科学可视化、教育培训等领域也发挥着重要作用，例如，通过三维重建技术，医生可以更好地理解复杂的解剖结构，学生可以通过虚拟实验室进行互动学习。

本项目的目的在于通过三维室内场景模拟，探索实时渲染技术的实现与应用。实时渲染技术是计算机图形学中的一个重要研究方向，它允许用户在交互过程中即时看到图像的变化，这对于创建动态和互动的用户体验至关重要。通过本项目，我们希望能够实现一个高效的三维室内场景模拟系统，使用户能够在虚拟环境中自由探索和互动。

1.2 **研究现状**

当前，三维室内场景模拟的技术发展迅速，已经形成了一系列成熟的实现方式。随着计算机硬件性能的提升和图形处理单元（GPU）技术的进步，实时渲染的效果越来越接近于真实世界的视觉体验。现代的三维场景模拟技术通常依赖于多种算法和工具的结合使用，以实现高效的图形渲染和物理模拟。

在众多相关技术中，OpenGL（开放图形库）是最为常用的图形API之一，它为开发者提供了丰富的功能接口，支持2D和3D图形的渲染。OpenGL的优势在于其跨平台性和广泛的社区支持，使得开发者能够在不同的操作系统上实现一致的图形效果。此外，光照模型也是三维场景模拟中不可或缺的技术之一。常见的光照模型包括Phong光照模型、Blinn-Phong光照模型和物理基础光照模型（PBR），这些模型通过模拟光与物体表面的相互作用，能够生成更加真实的光影效果。

除了OpenGL和光照模型，现代三维场景模拟还涉及到其他技术，如纹理映射、阴影映射、环境光遮蔽（AO）等。这些技术共同作用，使得三维场景的表现力和真实感得到了显著提升。随着深度学习和人工智能技术的发展，基于神经网络的图像生成和增强技术也逐渐被引入到三维图形学中，为场景模拟提供了新的可能性。

1.3 **研究目标**

本项目的研究目标是设计一个具有真实感的三维室内场景模拟系统，支持用户视角调整与家具交互功能。具体而言，我们希望通过以下几个方面来实现这一目标：

1. **真实感渲染**：利用先进的光照模型和纹理映射技术，确保三维室内场景的视觉效果尽可能接近真实世界。我们将研究如何在实时渲染中平衡性能与画质，以便在不同硬件条件下都能提供流畅的用户体验。

2. **用户视角调整**：实现用户在三维场景中的自由视角调整功能，使用户能够从不同的角度和高度观察室内环境。这一功能不仅增强了用户的沉浸感，还使得用户能够更好地理解空间布局和设计细节。

3. **家具交互功能**：设计并实现家具的交互功能，允许用户在虚拟环境中与家具进行互动，例如移动、旋转和更改颜色等。这一功能将使得用户能够在模拟环境中进行个性化的设计和布局，提升用户的参与感和满意度。

4. **性能优化**：在实现上述功能的同时，我们还将关注系统的性能优化，确保在复杂场景下依然能够保持高帧率和流畅的交互体验。我们将研究各种优化技术，如视锥体剔除、细节层次（LOD）管理和实例化渲染等，以提高系统的整体性能。

通过以上研究目标的实现，我们希望能够为三维室内场景模拟领域提供一个全面、有浓厚动画色彩的且互动性强的解决方案，推动相关技术的发展，并为用户提供更好的体验。

---

## 2. 实验方法与技术路线

2.1 **实验方法**  

- 采用的实验方法：基于OpenGL实现三维建模、场景构建、实时渲染和交互功能。  
- 项目开发的主要环节：三维建模、场景搭建、光照实现、用户交互开发、性能优化。

2.2 **技术路线**  

- **三维建模**  
  - 使用Blender和其他开源模型库获取基础家具模型，如桌椅、沙发等。  
  - 对模型进行优化和修改，确保适配场景需求。  
- **场景构建**  
  - 使用OpenGL加载模型、贴图，并完成室内场景布局。  
  - 搭建基本的墙壁、地板等环境模型。  
- **光照与渲染**  
  - 实现Blinn-Phong 光照模型，加入点光源和环境光。  
  - 基于深度缓冲实现阴影映射，增强场景真实感。  
- **用户交互**  
  - 通过鼠标和键盘控制飞行摄像机或第一人称视角观察场景。  

2.3 **开发工具与环境**  

- **编程语言**：C++
- **图形库**：OpenGL
- **开发平台**：Windows
- **辅助工具**：Blender（模型制作），Visual Studio 2022 / VS Code（代码编辑）

---

## 3. 实验设计与实现

3.1 **实验设计**  

- 设计的基本流程：  
  - 场景初始化（加载模型与纹理）。  
  - 光照与阴影实现（Blinn-Phong 光照模型与阴影映射）。  
  - 用户交互功能（视角调整与家具交互）。  
- 系统模块划分：  
  - 模型加载模块。  
  - 光照渲染模块。  
  - 用户交互模块。  

3.2 **具体实现**  

- **三维建模与场景构建**：  

  - 描述模型获取、纹理贴图和室内布局的实现过程。  
我

- **光照与阴影**：  

  - Blinn-Phong 光照模型是一种改进的 Phong 模型，它通过引入半程向量优化了镜面反射的计算，广泛应用于实时渲染中。

     **光源类型**

    1. **环境光 (Ambient Light)**  
       模拟场景中均匀分布的基础光线，通常没有方向性，用于弱化阴影过暗的效果。
       - 公式：`ambient = Ka * La`
         - `Ka`：材质的环境光反射系数。
         - `La`：光源的环境光强度。

    2. **漫反射光 (Diffuse Light)**  
       模拟光源与物体表面直接接触的扩散效果，由光源方向与表面法向量的夹角决定。
       - 公式：`diffuse = Kd * Ld * max(dot(l, n), 0.0)`
         - `Kd`：材质的漫反射光反射系数。
         - `Ld`：光源的漫反射光强度。
         - `l`：光源方向向量（归一化）。
         - `n`：法向量（归一化）。

    3. **镜面反射光 (Specular Light)**  
       模拟高光效果，光线在光滑表面上的反射遵循镜面反射定律。
       - Blinn-Phong 模型公式：  
         `specular = Ks * Ls * pow(max(dot(n, halfwayDir), 0.0), shininess)`
         - `Ks`：材质的镜面反射光反射系数。
         - `Ls`：光源的镜面反射光强度。
         - `halfwayDir`：半程向量，计算公式为：  
           `halfwayDir = normalize(l + v)`  
           其中，`l` 是光源方向，`v` 是视线方向。
         - `shininess`：控制高光的锐度。

    4. **光衰减 (Attenuation)**  
       模拟点光源光强随距离的衰减效果，通常使用以下公式：  
       `attenuation = 1.0 / (1.0 + k1 * d + k2 * d^2)`
       - `d`：光源与片段之间的距离。
       - `k1`：线性衰减系数。
       - `k2`：二次衰减系数。

    **光照计算公式**

    结合上述光源类型，片段的最终光照颜色为：

    ```text
    FragColor = (ambient + diffuse + specular) * attenuation * texture_color
    ```

    其中：

    - `ambient`、`diffuse`、`specular` 分别表示环境光、漫反射光和镜面反射光的贡献。
    - `attenuation` 是光衰减系数。
    - `texture_color` 是从纹理采样得到的颜色值。
    - 最终颜色通过伽马校正优化显示效果。

    伽马校正公式：

    ```text
    finalColor = pow(color, 1.0 / gamma)
    ```

    其中，`gamma` 通常取值为 `2.2`。

  - 实现基于法线和光照方向的简单阴影模拟
  
    在不使用复杂的渲染管线（如阴影贴图或阴影体积）的情况下，通过修改片段着色器，可以模拟出一种简化的阴影效果。以下是实现的详细描述及相关计算公式。
  
    **实现原理**
  
    1. **法线与光照方向的点积**：  
       点积的结果反映了光线与表面方向的关系：
       
       - 值越接近 `1.0`，说明表面正对光源，亮度越高。
       - 值越接近 `0.0` 或负值，说明表面逐渐背向光源，亮度越低。
       
       **公式**：`shadowFactor = max(dot(n, l), 0.0)`
       
       其中 `n` 是表面的单位法向量，`l` 是光照方向的单位向量。
       
    2. **模拟阴影区域**：  
       当点积结果较小时，进一步降低光照强度，使表面看起来更暗，从而模拟阴影效果。
  
    3. **光照模型**：  
       使用经典的 Blinn-Phong 光照模型，包括环境光、漫反射光和镜面反射光的计算，同时将阴影因子应用于漫反射光和镜面反射光。
  
    **着色器的调整**
  
    **1. 法线与光照方向的单位化**
  
    在光照计算中，法线和光照方向的单位化非常重要，以确保点积计算正确：
  
    ```glsl
    vec3 normalizedN = normalize(n); // 单位化法线
    vec3 normalizedL = normalize(l); // 单位化光照方向
    ```
  
    **2. 阴影因子的计算**
  
    使用法线和光照方向的点积计算阴影因子 `shadowFactor`：
  
    ```glsl
    float shadowFactor = max(dot(normalizedN, normalizedL), 0.0);
    ```
  
    - 当表面背向光源时，点积会小于 `0`，通过 `max` 函数将其限制为 `0.0`，避免负值影响计算。
  
    进一步调整，模拟更深的阴影效果：
  
    ```glsl
    if(shadowFactor < 0.3) {
        shadowFactor *= 0.3; // 减少光照强度
    }
    ```
  
    - 当点积值小于 `0.3` 时，人为降低光照强度，使表面看起来更暗。
  
    **3. 光照计算**
  
    根据 Blinn-Phong 模型，计算总光照：
  
    - **环境光**：
      ```glsl
      vec3 Ia = Ka * La; // 环境光分量
      ```
  
    - **漫反射光**：
      
      ```glsl
      float diff = max(dot(normalizedL, normalizedN), 0.0);
      diff = pow(diff, 1.5); // 提升亮部和暗部的对比
      vec3 Id = Kd * Ld * diff;
      ```
      
      使用 `pow` 函数提升漫反射的非线性对比度，增加亮部和暗部的视觉差异。
      
    - **镜面反射光**（Blinn-Phong 模型）：
      
      ```glsl
      vec3 halfwayDir = normalize(normalizedL + normalizedV);
      float spec = pow(max(dot(normalizedN, halfwayDir), 0.0), shininess);
      spec = spec * (0.5 + 0.5 * pow(diff, 2.0)); // 结合漫反射
      vec3 Is = Ks * Ls * spec;
      ```
      
      镜面反射光通过调整高光强度和锐度，结合漫反射的分布，使高光更自然。
  
    **4. 阴影因子的应用**
  
    将阴影因子 `shadowFactor` 作用于漫反射光和镜面反射光：
  
    ```glsl
    vec3 lighting = (Ia + (Id + Is) * shadowFactor) * attenuation;
    ```
  
    - 环境光 `Ia` 不受阴影影响，保持整体场景的柔和光照。
    - 漫反射光 `Id` 和镜面反射光 `Is` 乘以阴影因子 `shadowFactor`，模拟阴影效果。
  
    **5. 伽马校正**
  
    最终对输出颜色进行伽马校正，使得颜色在显示器上更自然：
  
    ```glsl
    vec3 finalColor = lighting * objectColor;
    finalColor = pow(finalColor, vec3(1.0 / 2.2)); // 伽马校正
    FragColor = vec4(finalColor, 1.0);
    ``` 

- **用户交互**：  

  - 视角调整：实现飞行摄像机或第一人称视角的控制逻辑。  
  - 家具交互：通过鼠标点击或拖拽实现家具的颜色变化、位置调整等功能。  

---

## 4. 实验结果与分析

4.1 **实验结果**  

- 室内场景构建：  

  - 展示完整的室内场景，包括家具模型、地板、墙壁等。  

    

- 光照与渲染：  

  - 展示光照效果（如点光源、环境光）及其对场景的影响。  

    

- 用户交互功能：  

  - 展示视角调整功能的实际效果（如飞行摄像机视角切换）。  

    

  

4.2 **结果分析**  

- 对实验结果进行分析：  
  - 评价场景构建、光照渲染、交互功能的实现效果是否符合预期。  
  - 分析系统性能（如帧率、响应速度）是否满足实时渲染需求。  
  - 如果有性能优化或扩展功能，分析其对系统的改进效果。  

---



## 5. 讨论

5.1 **问题与不足**  

- 实验过程中遇到的主要问题及解决方案。  
- 系统在场景真实感、交互功能等方面的不足之处。  

5.2 **改进方向**  

- 在建模、渲染、交互等方面的可能改进点。  
- 对未来类似项目的建议。  

---

## 6. 结论

6.1 **实验总结**  

- 概述实验的整体流程与成果。  
- 强调项目目标的实现情况。  

6.2 **实际意义**  

- 本项目对三维场景模拟、实时渲染技术的学习与实践意义。  

6.3 **未来展望**  

- 展望三维室内场景模拟技术的进一步发展和应用前景。  

---

## 7. 附录

- 源代码：包含关键模块的代码实现，见附件。

```
IndoorSceneSimulator/
│
├── resources/
│   ├── shaders/
│   │   ├── fragment.glsl
│   │   └── vertex.glsl
│   └── objs/
│       ├── wall.png
│       ├── grey.png
│       └── ... (其他纹理)
│
├── src/
│   ├── main.cpp
│   ├── myglwidget.cpp
│   ├── myglwidget.h
│   ├── Camera.cpp
│   ├── Camera.h
│   ├── utils.cpp
│   └── utils.h
│
├── CGTemplate.pro
└── README.md
```

- 演示视频：见附件。
